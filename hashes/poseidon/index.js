const ZqField = require("ffjavascript").ZqField;

const { SNARK_SCALAR_FIELD, C, M } = require('./config');

// Prime 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001
const F = new ZqField(SNARK_SCALAR_FIELD);

// Using recommended parameters from whitepaper https://eprint.iacr.org/2019/458.pdf (table 2, table 8)
// Generated by https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/calc_round_numbers.py
// And rounded up to nearest integer that divides by t
const N_ROUNDS_F = 8;
const N_ROUNDS_P = [56, 57, 56, 60, 60, 63, 64, 63];

const pow5 = a => F.mul(a, F.square(F.square(a)));

module.exports = function poseidonHash(inputs) {
  if (!Array.isArray(inputs) ||
    !inputs.length ||
    !(inputs.length < N_ROUNDS_P.length - 1)
  ) {
    throw Error('invalid inputs');
  }

  const t = inputs.length + 1;
  const nRoundsF = N_ROUNDS_F;
  const nRoundsP = N_ROUNDS_P[t - 2];

  let state = [...inputs.map(a => F.e(a)), BigInt(0)];
  for (let r = 0; r < nRoundsF + nRoundsP; r++) {

    state = state.map((a, i) => {
      return F.add(a, BigInt(C[t - 2][r * t + i]));
    });

    if (r < nRoundsF / 2 || r >= nRoundsF / 2 + nRoundsP) {
      state = state.map(a => pow5(a));
    } else {
      state[0] = pow5(state[0]);
    }

    // no matrix multiplication in the last round
    if (r < nRoundsF + nRoundsP - 1) {
      state = state.map((_, i) =>
        state.reduce((acc, a, j) => F.add(
          acc,
          F.mul(BigInt(M[t - 2][j][i]), a)
        ), F.zero)
      );
    }
  }
  return F.normalize(state[0]);
};
